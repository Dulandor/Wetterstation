// Code generated by senseBox Blockly on Wed Feb 19 2025 19:28:24 GMT+0100 (Mitteleurop√§ische Normalzeit)

#include <senseBoxIO.h>
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h> // http://librarymanager/All#Adafruit_GFX_Library
#include <Adafruit_SSD1306.h> // http://librarymanager/All#Adafruit_SSD1306
#include <Adafruit_HDC1000.h> // http://librarymanager/All#Adafruit_HDC1000_Library
#include <Adafruit_DPS310.h> // http://librarymanager/All#Adafruit_DPS310   
#include <WiFi101.h>
#include <LTR329.h>
#include <VEML6070.h>
#include <SD.h>
#include <NTPClient.h>
#include <WiFiUdp.h>
// #include <WebUtil.h>

char ssid[] = "FRITZ!Box 6490 Cable";
char pass[] = "33317160926124716429";
// char ssid[] = "IPhone von Leander";
// char pass[] = "arvinlol";
// char ssid[] = "Wombats";
// char pass[] = "12345678";


int status = WL_IDLE_STATUS;

File Data;
const char SENSOR_IDRID[] PROGMEM = "sensorID";


Adafruit_HDC1000 hdc = Adafruit_HDC1000();
Adafruit_DPS310 dps;

bool lightsensortype = 0; //0 for tsl - 1 for ltr
//settings for LTR sensor
LTR329 LTR;
unsigned char gain = 1;
unsigned char integrationTime = 0;
unsigned char measurementRate = 3;

VEML6070 veml;

// Web server
WiFiServer server(80);

// NTP settings
WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "pool.ntp.org", 3600, 60000); // Base UTC+1 (MEZ), update every 60 seconds

// Add NTP retry variables
const int NTP_MAX_RETRIES = 3;
const int NTP_RETRY_DELAY = 2000; // 2 seconds between retries
bool ntpInitialized = false;

// Time tracking variables
unsigned long lastNTPUpdate = 0;
const unsigned long NTP_UPDATE_INTERVAL = 3600000; // Update NTP every hour
unsigned long lastDataSave = 0;
const unsigned long DATA_SAVE_INTERVAL = 300000; // Save data every 5 minutes (300000 ms)
unsigned long lastMillis = 0;
unsigned long timeOffset = 0; // Offset between millis() and real time
bool timeInitialized = false;

// Add power management variables
unsigned long lastWiFiRetry = 0;
const unsigned long WIFI_RETRY_INTERVAL = 300000; // Try to reconnect every 5 minutes
bool wifiEnabled = true;
int connectionAttempts = 0;
const int MAX_CONNECTION_ATTEMPTS = 3;

// Add LED status variables
const int STATUS_LED = LED_BUILTIN;  // Built-in LED
unsigned long lastBlinkTime = 0;
const int BLINK_INTERVAL = 500;  // 500ms between blinks
int blinkCount = 0;
const int MAX_BLINKS = 5;  // Maximum number of blinks for status

// Data structure for sensor readings
struct SensorData {
  float temperature;
  float humidity;
  float pressure;
  float altitude;
  uint32_t light;
  float uv;
  unsigned long timestamp;
};

// Function declarations
int read_reg(byte address, uint8_t reg);
void write_reg(byte address, uint8_t reg, uint8_t val);
void Lightsensor_begin();
uint32_t Lightsensor_getIlluminance();
void saveDataToSD(SensorData data);
String getCurrentData(sensors_event_t temp_event, sensors_event_t pressure_event);
String getDashboardData();
String readHistoricalData();

// Add time tracking variables
unsigned long startTime = 0;
unsigned long lastTimeUpdate = 0;
unsigned long currentSeconds = 0;

// Add these declarations after the other global variables
sensors_event_t temp_event;
sensors_event_t pressure_event;

int read_reg(byte address, uint8_t reg)
{
  int i = 0;
  Wire.beginTransmission(address);
  Wire.write(reg);
  Wire.endTransmission();
  Wire.requestFrom((uint8_t)address, (uint8_t)1);
  delay(1);
  if(Wire.available())
  i = Wire.read();
  return i;
}

void write_reg(byte address, uint8_t reg, uint8_t val)
{
  Wire.beginTransmission(address);
  Wire.write(reg);
  Wire.write(val);
  Wire.endTransmission();
}

void Lightsensor_begin()
{
  unsigned int u = 0;
  u = read_reg(0x29, 0x80 | 0x0A); //id register
  if ((u & 0xF0) == 0xA0)            // TSL45315
  {
    write_reg(0x29, 0x80 | 0x00, 0x03); //control: power on
    write_reg(0x29, 0x80 | 0x01, 0x02); //config: M=4 T=100ms
    delay(120);
    lightsensortype = 0; //TSL45315
  }
  else
  {
    LTR.begin();
    LTR.setControl(gain, false, false);
    LTR.setMeasurementRate(integrationTime, measurementRate);
    LTR.setPowerUp(); //power on with default settings
    delay(10); //Wait 10 ms (max) - wakeup time from standby
    lightsensortype = 1;                     //
  }
}

uint32_t Lightsensor_getIlluminance()
{
  unsigned int lux = 0;
  if (lightsensortype == 0) // TSL45315
  {
    unsigned int u = (read_reg(0x29, 0x80 | 0x04) << 0);  //data low
    u |= (read_reg(0x29, 0x80 | 0x05) << 8); //data high
    lux = u * 4; // calc lux with M=4 and T=100ms
  }
  else if (lightsensortype == 1) //LTR-329ALS-01
  {
    delay(100);
    unsigned int data0, data1;
    for (int i = 0; i < 5; i++) {
      if (LTR.getData(data0, data1)) {
        if(LTR.getLux(gain, integrationTime, data0, data1, lux));
        if(lux > 0) break;
        else delay(10);
      }
      else {
        byte error = LTR.getError();
      }
    }
  }
  return lux;
}

// Function to check if it's summer time (MESZ)
bool isSummerTime() {
  timeClient.update();
  unsigned long epochTime = timeClient.getEpochTime();
  
  // Convert epoch time to date components
  int year = 1970 + (epochTime / 31536000);
  int month = 1 + ((epochTime % 31536000) / 2592000);
  int day = 1 + ((epochTime % 2592000) / 86400);
  
  // Summer time in Germany: Last Sunday in March to last Sunday in October
  if (month > 3 && month < 10) {
    return true;
  } else if (month == 3) {
    int lastSunday = 31 - ((5 + year + year/4) % 7);
    if (day >= lastSunday) return true;
  } else if (month == 10) {
    int lastSunday = 31 - ((5 + year + year/4) % 7);
    if (day < lastSunday) return true;
  }
  return false;
}

bool connectToWiFi() {
  if (!wifiEnabled) return false;
  
  Serial.print("üîå Verbinden mit WLAN: ");
  Serial.println(ssid);
  
  // Reset WiFi module
  WiFi.disconnect();
  delay(1000);
  
  // Print firmware version
  Serial.print("WiFi firmware version: ");
  Serial.println(WiFi.firmwareVersion());
  
  // Try to connect with timeout
  unsigned long startAttemptTime = millis();
  status = WiFi.begin(ssid, pass);
  
  while (status != WL_CONNECTED && millis() - startAttemptTime < 15000) { // 15 second timeout
    delay(500);
    status = WiFi.status();
    Serial.print(".");
  }
  Serial.println();
  
  if (status == WL_CONNECTED) {
    Serial.println("‚úÖ WLAN verbunden");
    IPAddress ip = WiFi.localIP();
    String ipStr = String(ip[0]) + "." + String(ip[1]) + "." + String(ip[2]) + "." + String(ip[3]);
    Serial.print("üì° IP-Adresse: ");
    Serial.println(ipStr);
    
    // Print signal strength
    long rssi = WiFi.RSSI();
    Serial.print("Signal strength (RSSI): ");
    Serial.print(rssi);
    Serial.println(" dBm");
    
    // Start web server
    server.begin();
    Serial.println("üõ∞Ô∏è Webserver gestartet");
    
    // Initialize NTP client
    timeClient.begin();
    timeClient.setUpdateInterval(30000); // Update every 30 seconds
    
    // Try to sync NTP time
    if (syncNTPTime()) {
      Serial.println("‚úÖ Time synchronization complete");
    } else {
      Serial.println("‚ö†Ô∏è Time synchronization failed - will retry in loop");
    }
    
    return true;
  } else {
    Serial.println("‚ùå WLAN-Verbindung fehlgeschlagen");
    Serial.print("Failed with status: ");
    switch (status) {
      case WL_IDLE_STATUS:
        Serial.println("IDLE");
        break;
      case WL_NO_SSID_AVAIL:
        Serial.println("NO_SSID_AVAIL");
        break;
      case WL_CONNECT_FAILED:
        Serial.println("CONNECT_FAILED");
        break;
      case WL_CONNECTION_LOST:
        Serial.println("CONNECTION_LOST");
        break;
      case WL_DISCONNECTED:
        Serial.println("DISCONNECTED");
        break;
      default:
        Serial.println("UNKNOWN");
        break;
    }
    return false;
  }
}

bool syncNTPTime() {
  Serial.println("üïí Attempting NTP time sync...");
  
  // Initialize UDP if not already done
  if (!ntpUDP.begin(2390)) {  // Use a random port
    Serial.println("‚ùå Failed to start UDP");
    return false;
  }
  
  Serial.println("Sending NTP request...");
  
  int retries = 0;
  while (retries < NTP_MAX_RETRIES) {
    Serial.print("Attempt ");
    Serial.print(retries + 1);
    Serial.print(" of ");
    Serial.println(NTP_MAX_RETRIES);
    
    unsigned long startAttempt = millis();
    if (timeClient.update()) {
      unsigned long duration = millis() - startAttempt;
      Serial.print("‚úÖ NTP sync successful in ");
      Serial.print(duration);
      Serial.println("ms");
      
      timeOffset = timeClient.getEpochTime() * 1000 - millis();
      timeInitialized = true;
      ntpInitialized = true;
      
      Serial.print("Current date and time: ");
      Serial.println(getFormattedTimestamp());
      Serial.print("Time zone: ");
      Serial.println(isSummerTime() ? "MESZ (UTC+2)" : "MEZ (UTC+1)");
      
      return true;
    }
    
    retries++;
    if (retries < NTP_MAX_RETRIES) {
      Serial.print("Retry ");
      Serial.print(retries);
      Serial.print(" of ");
      Serial.println(NTP_MAX_RETRIES);
      delay(NTP_RETRY_DELAY);
    }
  }
  
  Serial.println("‚ùå NTP request timed out");
  return false;
}

void setup() {
  // Initialize LED
  pinMode(STATUS_LED, OUTPUT);
  digitalWrite(STATUS_LED, LOW);
  
  Wire.begin();
  // 1. Serielle Verbindung starten
  Serial.begin(9600);
  
  // Instead, add a non-blocking timeout for serial initialization
  unsigned long startTime = millis();
  while (!Serial && millis() - startTime < 3000) {
    // Wait up to 3 seconds for serial connection
    delay(10);
  }
  
  Serial.println("üöÄ Setup gestartet");
  
  // Initialize start time
  startTime = millis();
  
  // SD.begin(28);
  // Initialize SD card with proper pins
  if (!SD.begin(28)) {
    Serial.println("‚ùå SD card initialization failed!");
    // Blink LED 5 times to indicate SD card error
    for(int i = 0; i < 5; i++) {
      digitalWrite(STATUS_LED, HIGH);
      delay(100);
      digitalWrite(STATUS_LED, LOW);
      delay(100);
    }
  } else {
    Serial.println("‚úÖ SD card initialized");
    // Create header in data file if it doesn't exist
    if (!SD.exists("data.txt")) {
      File dataFile = SD.open("data.txt", FILE_WRITE);
      if (dataFile) {
        dataFile.println("timestamp,temperature,humidity,pressure,altitude,light,uv");
        dataFile.close();
        Serial.println("‚úÖ Created data file with headers");
      }
    }
  }

  // 3. WLAN-Modul √ºberpr√ºfen
  Serial.println("üîç Checking WiFi shield...");
  if (WiFi.status() == WL_NO_SHIELD) {
    Serial.println("‚ùå Kein WiFi-Shield gefunden!");
    // Blink LED 4 times to indicate WiFi shield error
    for(int i = 0; i < 4; i++) {
      digitalWrite(STATUS_LED, HIGH);
      delay(100);
      digitalWrite(STATUS_LED, LOW);
      delay(100);
    }
    wifiEnabled = false;
  } else {
    Serial.println("üîç WLAN-Modul erkannt");
    // Try to connect to WiFi with multiple attempts
    for (int i = 0; i < MAX_CONNECTION_ATTEMPTS; i++) {
      Serial.print("üîå WiFi connection attempt ");
      Serial.print(i + 1);
      Serial.print(" of ");
      Serial.println(MAX_CONNECTION_ATTEMPTS);
      
      // Blink LED to show connection attempt
      digitalWrite(STATUS_LED, HIGH);
      delay(100);
      digitalWrite(STATUS_LED, LOW);
      
      if (connectToWiFi()) {
        // Success - solid LED for 2 seconds
        digitalWrite(STATUS_LED, HIGH);
        delay(2000);
        digitalWrite(STATUS_LED, LOW);
        break;
      }
      
      // Wait longer between attempts
      delay(5000);
    }
  }

  // 6. Sensoren initialisieren
  if (!hdc.begin()) {
    Serial.println("‚ùå HDC1000 nicht erkannt!");
  } else {
    Serial.println("‚úÖ HDC1000 bereit");
  }

  if (!dps.begin_I2C(0x76)) {
    Serial.println("‚ùå DPS310 nicht erkannt!");
  } else {
    Serial.println("‚úÖ DPS310 bereit");
    dps.configurePressure(DPS310_64HZ, DPS310_64SAMPLES);
    dps.configureTemperature(DPS310_64HZ, DPS310_64SAMPLES);
  }

  Lightsensor_begin();
  veml.begin();
}

void loop() {
  // Update LED status based on WiFi connection
  if (WiFi.status() == WL_CONNECTED) {
    // Connected - slow blink (1 second on, 1 second off)
    if (millis() - lastBlinkTime >= 1000) {
      digitalWrite(STATUS_LED, !digitalRead(STATUS_LED));
      lastBlinkTime = millis();
    }
  } else {
    // Not connected - fast blink (100ms on, 100ms off)
    if (millis() - lastBlinkTime >= 100) {
      digitalWrite(STATUS_LED, !digitalRead(STATUS_LED));
      lastBlinkTime = millis();
    }
  }

  // Try to reconnect to WiFi periodically if it's not connected
  if (WiFi.status() != WL_CONNECTED && millis() - lastWiFiRetry > WIFI_RETRY_INTERVAL) {
    Serial.println("üîÑ Attempting to reconnect to WiFi...");
    // Blink LED 3 times to show reconnection attempt
    for(int i = 0; i < 3; i++) {
      digitalWrite(STATUS_LED, HIGH);
      delay(100);
      digitalWrite(STATUS_LED, LOW);
      delay(100);
    }
    
    if (connectToWiFi()) {
      lastWiFiRetry = millis();
    }
  }
  
  // Update NTP time if needed and WiFi is available
  if (WiFi.status() == WL_CONNECTED) {
    if (millis() - lastNTPUpdate > NTP_UPDATE_INTERVAL) {
      if (syncNTPTime()) {
        lastNTPUpdate = millis();
      } else {
        Serial.println("‚ö†Ô∏è NTP sync failed - will retry in 5 minutes");
        lastNTPUpdate = millis() - (NTP_UPDATE_INTERVAL - 300000); // Retry in 5 minutes instead of 1 hour
      }
    }
  } else if (timeInitialized) {
    // If WiFi is down but we have a time offset, we can still track time
    unsigned long currentTime = (millis() + timeOffset) / 1000;
    if (currentTime % 300 == 0) { // Log every 5 minutes when offline
      Serial.println("üì° WiFi disconnected - using local time tracking");
      Serial.print("Current date and time: ");
      Serial.println(getFormattedTimestamp());
    }
  }
  
  // Only collect and save data at the configured interval
  if (millis() - lastDataSave >= DATA_SAVE_INTERVAL) {
    // Update sensor readings
    dps.getEvents(&temp_event, &pressure_event);
    
    // Collect sensor data
    SensorData data = {
      hdc.readTemperature(),
      hdc.readHumidity(),
      pressure_event.pressure,
      dps.readAltitude(1013),
      Lightsensor_getIlluminance(),
      veml.getUV(),
      getCurrentTimestamp()
    };

    // Save data to SD card
    saveDataToSD(data);
    lastDataSave = millis();
  }

  // Handle web clients
  WiFiClient client = server.available();
  if (client) {
    Serial.println("üîå New client connected");
    String currentLine = "";
    String request = "";
    unsigned long timeout = millis() + 5000; // 5 second timeout
    
    while (client.connected() && millis() < timeout) {
      if (client.available()) {
        char c = client.read();
        request += c;
        
        if (c == '\n') {
          if (currentLine.length() == 0) {
            Serial.println("üì® Received HTTP request");
            
            // Check if it's a dashboard request
            if (request.indexOf("GET /dashboard") >= 0) {
              Serial.println("üìä Dashboard request received");
              String dashboardData = getDashboardData();
              
              // Send HTTP response
              client.println("HTTP/1.1 200 OK");
              client.println("Content-Type: text/html");
              client.println("Connection: close");
              client.println();
              
              // Send the dashboard data in chunks
              const int chunkSize = 512;
              for (int i = 0; i < dashboardData.length(); i += chunkSize) {
                String chunk = dashboardData.substring(i, min(i + chunkSize, dashboardData.length()));
                client.print(chunk);
                delay(10); // Small delay between chunks
              }
              
              Serial.println("‚úÖ Dashboard data sent to client");
            } else {
              Serial.println("üìà Live data request received");
              
              // Update sensor readings for live data
              dps.getEvents(&temp_event, &pressure_event);
              
              // Send HTTP response
              client.println("HTTP/1.1 200 OK");
              client.println("Content-Type: text/html");
              client.println("Connection: close");
              client.println();
              
              String liveData = getCurrentData(temp_event, pressure_event);
              client.print(liveData);
              Serial.println("‚úÖ Live data sent to client");
            }
            
            break;
          } else {
            currentLine = "";
          }
        } else if (c != '\r') {
          currentLine += c;
        }
      }
    }
    client.stop();
    Serial.println("üîå Client disconnected");
  }
  
  delay(1000); // Wait 1 second between readings
}

// Function to get current timestamp
unsigned long getCurrentTimestamp() {
  if (timeInitialized) {
    return (millis() + timeOffset) / 1000; // Convert to seconds
  } else {
    return millis() / 1000; // Fallback to millis() if time not initialized
  }
}

// Function to get formatted timestamp
String getFormattedTimestamp() {
  if (timeInitialized) {
    // Get the current time from NTP client
    timeClient.update();
    unsigned long epochTime = timeClient.getEpochTime();
    
    // Add one hour if it's summer time
    if (isSummerTime()) {
      epochTime += 3600; // Add one hour for MESZ
    }
    
    // Convert epoch time to date components using a more accurate method
    int year = 1970;
    int month = 1;
    int day = 1;
    
    // Calculate years
    while (epochTime >= 31536000) {
      epochTime -= 31536000;
      year++;
      // Add leap year day
      if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {
        epochTime -= 86400;
      }
    }
    
    // Calculate months
    int daysInMonth[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {
      daysInMonth[1] = 29; // February in leap year
    }
    
    while (epochTime >= 86400) {
      if (epochTime >= daysInMonth[month - 1] * 86400) {
        epochTime -= daysInMonth[month - 1] * 86400;
        month++;
      } else {
        break;
      }
    }
    
    // Calculate day
    day = 1 + (epochTime / 86400);
    epochTime %= 86400;
    
    // Calculate time
    int hour = epochTime / 3600;
    epochTime %= 3600;
    int minute = epochTime / 60;
    int second = epochTime % 60;
    
    char buffer[30];
    sprintf(buffer, "%02d.%02d.%04d;%02d:%02d:%02d", 
      day, month, year,
      hour, minute, second);
    return String(buffer);
  } else {
    // Fallback to millis() if time not initialized
    unsigned long currentMillis = millis() / 1000;
    int hour = (currentMillis / 3600) % 24;
    int minute = (currentMillis / 60) % 60;
    int second = currentMillis % 60;
    
    char buffer[30];
    sprintf(buffer, "00.00.0000;%02d:%02d:%02d", 
      hour, minute, second);
    return String(buffer);
  }
}

void saveDataToSD(SensorData data) {
  if (!SD.exists("data.txt")) {
    File dataFile = SD.open("data.txt", FILE_WRITE);
    if (dataFile) {
      dataFile.println("timestamp,temperature,humidity,pressure,altitude,light,uv");
      dataFile.close();
    }
  }
  
  File dataFile = SD.open("data.txt", FILE_WRITE);
  if (dataFile) {
    dataFile.print(getFormattedTimestamp());
    dataFile.print(",");
    dataFile.print(data.temperature);
    dataFile.print(",");
    dataFile.print(data.humidity);
    dataFile.print(",");
    dataFile.print(data.pressure);
    dataFile.print(",");
    dataFile.print(data.altitude);
    dataFile.print(",");
    dataFile.print(data.light);
    dataFile.print(",");
    dataFile.println(data.uv);
    dataFile.close();
    Serial.println("‚úÖ Data saved to SD card");
  } else {
    Serial.println("‚ùå Error opening data file for writing");
  }
}

String getCurrentData(sensors_event_t temp_event, sensors_event_t pressure_event) {
  String html = "<!DOCTYPE html>";
  html += "<html lang='de'>";
  html += "<head>";
  html += "<meta charset='UTF-8'>";
  html += "<meta http-equiv='refresh' content='30'>"; // 30 second refresh
  html += "<title>Weather Station Live Data</title>";
  html += "<style>";
  html += "body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background: #f0f2f5; }";
  html += ".container { max-width: 800px; margin: 0 auto; }";
  html += ".card { background: white; border-radius: 10px; padding: 20px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }";
  html += "h1 { color: #1a73e8; margin-bottom: 20px; }";
  html += "table { width: 100%; border-collapse: collapse; }";
  html += "td, th { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }";
  html += "th { background: #f8f9fa; }";
  html += ".nav { margin-bottom: 20px; }";
  html += ".nav a { color: #1a73e8; text-decoration: none; margin-right: 20px; }";
  html += "</style>";
  html += "</head>";
  html += "<body>";
  html += "<div class='container'>";
  html += "<div class='nav'>";
  html += "<a href='/'>Live Data</a>";
  html += "<a href='/dashboard'>Dashboard</a>";
  html += "</div>";
  html += "<div class='card'>";
  html += "<h1>Weather Station Live Data</h1>";
  html += "<table>";
  html += "<tr><th>Sensor</th><th>Value</th><th>Unit</th></tr>";
  html += "<tr><td>Temperature</td><td>" + String(hdc.readTemperature(), 2) + "</td><td>¬∞C</td></tr>";
  html += "<tr><td>Humidity</td><td>" + String(hdc.readHumidity(), 2) + "</td><td>%</td></tr>";
  html += "<tr><td>Pressure</td><td>" + String(pressure_event.pressure, 2) + "</td><td>hPa</td></tr>";
  html += "<tr><td>Altitude</td><td>" + String(dps.readAltitude(1013), 2) + "</td><td>m</td></tr>";
  html += "<tr><td>Light</td><td>" + String(Lightsensor_getIlluminance()) + "</td><td>lux</td></tr>";
  html += "<tr><td>UV Intensity</td><td>" + String(veml.getUV()) + "</td><td>¬µW/cm¬≤</td></tr>";
  html += "</table>";
  html += "</div></div></body></html>";
  return html;
}

String readHistoricalData() {
  Serial.println("üìä Starting to read historical data...");
  String data = "";
  
  if (!SD.exists("data.txt")) {
    Serial.println("‚ùå data.txt does not exist on SD card!");
    return data;
  }
  Serial.println("‚úÖ Found data.txt on SD card");

  File dataFile = SD.open("data.txt", FILE_READ);
  if (!dataFile) {
    Serial.println("‚ùå Failed to open data.txt!");
    return data;
  }
  Serial.println("‚úÖ Successfully opened data.txt");

  // Skip header line
  dataFile.readStringUntil('\n');
  Serial.println("‚úÖ Skipped header line");

  // Count total lines first
  int totalLines = 0;
  while (dataFile.available()) {
    if (dataFile.readStringUntil('\n').length() > 0) {
      totalLines++;
    }
  }
  Serial.print("üìà Total lines in file: ");
  Serial.println(totalLines);

  // Calculate sampling interval (show 10 points instead of 20)
  const int NUM_POINTS = 10;
  int interval = max(1, totalLines / NUM_POINTS);
  Serial.print("üìä Sampling interval: ");
  Serial.println(interval);

  // Reset file position
  dataFile.seek(0);
  dataFile.readStringUntil('\n'); // Skip header again

  // Read sampled lines
  int currentLine = 0;
  int sampledLines = 0;
  String lines[NUM_POINTS];
  
  while (dataFile.available() && sampledLines < NUM_POINTS) {
    String line = dataFile.readStringUntil('\n');
    if (line.length() > 0) {
      if (currentLine % interval == 0) {
        lines[sampledLines++] = line;
        Serial.print("üì• Sampled ");
        Serial.print(sampledLines);
        Serial.println(" points");
      }
      currentLine++;
    }
  }

  // Combine sampled lines
  for (int i = 0; i < sampledLines; i++) {
    data += lines[i] + "\n";
  }

  dataFile.close();
  Serial.println("‚úÖ Closed data.txt");
  Serial.print("üìä Total data length: ");
  Serial.println(data.length());
  return data;
}

String getDashboardData() {
  Serial.println("üåê Starting to generate dashboard data...");
  String historicalData = readHistoricalData();
  
  if (historicalData.length() == 0) {
    Serial.println("‚ö†Ô∏è No historical data available!");
    return "<!DOCTYPE html><html><body><h1>No data available</h1></body></html>";
  }
  Serial.println("‚úÖ Received historical data");

  // Build HTML in smaller chunks
  String html = "";
  html.reserve(1024); // Reduced reserve for simpler visualization

  // Header with basic styling
  html = "<!DOCTYPE html><html lang='de'><head>";
  html += "<meta charset='UTF-8'><meta http-equiv='refresh' content='30'>";
  html += "<title>Weather Station Dashboard</title>";
  html += "<style>";
  html += "body{font-family:Arial,sans-serif;margin:0;padding:20px;background:#f0f2f5}";
  html += ".container{max-width:800px;margin:0 auto}";
  html += ".card{background:white;border-radius:10px;padding:20px;margin-bottom:20px;box-shadow:0 2px 4px rgba(0,0,0,0.1)}";
  html += "h1{color:#1a73e8;margin-bottom:20px}";
  html += ".nav{margin-bottom:20px}";
  html += ".nav a{color:#1a73e8;text-decoration:none;margin-right:20px}";
  html += "table{width:100%;border-collapse:collapse;margin-top:20px}";
  html += "td,th{padding:12px;text-align:left;border-bottom:1px solid #ddd}";
  html += "th{background:#f8f9fa}";
  html += "</style></head><body>";
  html += "<div class='container'><div class='nav'>";
  html += "<a href='/'>Live Data</a><a href='/dashboard'>Dashboard</a></div>";
  html += "<div class='card'><h1>Weather Station Dashboard</h1>";

  // Data table
  html += "<h2>Sampled Data Points</h2>";
  html += "<table><tr><th>Timestamp</th><th>Temp</th><th>Hum</th><th>Press</th><th>Alt</th><th>Light</th><th>UV</th></tr>";

  Serial.println("üìã Starting to parse historical data...");
  int startPos = 0;
  int rowCount = 0;
  
  while (startPos < historicalData.length()) {
    int endPos = historicalData.indexOf('\n', startPos);
    if (endPos == -1) break;
    
    String line = historicalData.substring(startPos, endPos);
    String values[7];
    int valueIndex = 0;
    int lastComma = -1;
    
    // Parse the line
    for (int i = 0; i < line.length(); i++) {
      if (line[i] == ',' || i == line.length() - 1) {
        values[valueIndex++] = line.substring(lastComma + 1, i + (i == line.length() - 1 ? 1 : 0));
        lastComma = i;
      }
    }
    
    if (valueIndex == 7) {
      html += "<tr>";
      html += "<td>" + values[0] + "</td>";
      html += "<td>" + values[1] + "</td>";
      html += "<td>" + values[2] + "</td>";
      html += "<td>" + values[3] + "</td>";
      html += "<td>" + values[4] + "</td>";
      html += "<td>" + values[5] + "</td>";
      html += "<td>" + values[6] + "</td>";
      html += "</tr>";
      rowCount++;
      
      if (rowCount % 5 == 0) {
        Serial.print("üìä Processed ");
        Serial.print(rowCount);
        Serial.println(" rows");
      }
    }
    
    startPos = endPos + 1;
  }
  
  Serial.print("‚úÖ Finished parsing data. Total rows processed: ");
  Serial.println(rowCount);

  html += "</table></div></div></body></html>";
  
  Serial.print("üåê Final HTML length: ");
  Serial.println(html.length());
  Serial.println("‚úÖ Dashboard generation complete");
  
  return html;
}